# Create Prompt - 结构化提示词生成器

## 命令用途

将模糊的需求转换为 AI 友好的结构化提示词，通过自动提取项目上下文和主动调查，确保 AI 准确理解用户的真实意图。

## 使用方式

```
/create-prompt <模糊需求描述>
```

示例：
```
/create-prompt 帮我优化这个页面的性能
/create-prompt 加个导出功能
/create-prompt 这个接口有问题，帮我看看
```

---

## 执行流程

### 第一步：解析原始需求

分析用户输入，识别：
- **动作意图：** 用户想做什么（创建/修改/修复/优化/查询）
- **目标对象：** 针对什么（文件/功能/模块/接口）
- **期望结果：** 想要达到什么效果
- **模糊点：** 哪些信息不明确

### 第二步：自动提取项目上下文

根据需求自动收集相关信息：

**代码上下文：**
- 当前打开的文件
- 光标所在位置的代码
- 相关的导入和依赖
- 同目录下的相关文件

**项目上下文：**
- 项目技术栈（package.json、go.mod 等）
- 目录结构
- 相关配置文件
- 已有的类似实现

**Git 上下文：**
- 当前分支
- 最近的提交记录
- 未提交的更改

**执行的探索动作：**
```
1. 读取当前文件或用户指定的文件
2. 搜索项目中与需求关键词相关的代码
3. 查看相关模块的结构和依赖
4. 检查是否有相似功能的实现可参考
```

### 第三步：主动调查（发现模糊点时）

当需求不够明确时，生成针对性问题：

**关于范围的问题：**
- 这个改动只影响当前文件，还是需要修改多个地方？
- 需要考虑向后兼容吗？

**关于目标的问题：**
- 「优化性能」具体指什么？加载速度/渲染速度/内存占用？
- 「有问题」是报错了还是结果不符合预期？

**关于约束的问题：**
- 有没有不能改动的部分？
- 是否需要遵循现有的代码风格或模式？

**问题格式：**
```
为了生成精准的提示词，需要确认以下信息：

1. [问题1]
   - 选项 A: [选项描述]
   - 选项 B: [选项描述]

2. [问题2]
   [开放式问题]

请回复对应选项或补充说明。
```

### 第四步：生成结构化提示词

整合所有信息，生成结构化提示词。

---

## 结构化提示词模板

```markdown
## 任务

[一句话描述要完成的任务]

## 背景

[为什么要做这个任务，业务或技术背景]

## 当前状态

[相关代码/文件的当前情况]

```[language]
// 关键代码片段
```

## 目标

[具体要达到的效果，可衡量的标准]

- [ ] 目标1
- [ ] 目标2

## 约束

[需要遵守的限制条件]

- 技术约束：[如技术栈、兼容性要求]
- 风格约束：[如代码规范、命名约定]
- 范围约束：[如只改某个文件、不影响其他功能]

## 参考

[可参考的现有实现或相关代码]

- 文件：`path/to/reference.ts`
- 模式：[项目中已有的类似实现]

## 验收标准

[如何判断任务完成]

1. [标准1]
2. [标准2]
```

---

## 提示词优化规则

### 消除歧义
| 模糊表达 | 澄清后 |
|----------|--------|
| 「优化一下」 | 「减少首屏加载时间到 2s 以内」 |
| 「有问题」 | 「调用接口时返回 500 错误」 |
| 「加个功能」 | 「在列表页添加批量导出为 CSV 的功能」 |
| 「改一下样式」 | 「将按钮颜色从蓝色改为主题色 #6366f1」 |

### 补充隐含信息
- 技术栈和框架版本
- 相关的类型定义
- 依赖的服务或接口
- 错误信息和日志

### 提供充足上下文
- 不只给出要改的代码，还要给出相关的调用方和被调用方
- 说明代码在整体架构中的位置
- 指出需要保持一致的现有模式

---

## 输出格式

直接输出结构化提示词内容，无需额外包装。

---

## 快捷模式

对于常见场景，提供快捷处理：

### 修复 Bug
自动提取：错误信息、相关代码、调用链路

### 添加功能
自动提取：现有类似功能、相关接口、数据模型

### 重构优化
自动提取：当前实现、性能指标、代码复杂度

### 代码审查
自动提取：变更的代码、相关测试、规范要求

---

## 语言规范

- 提示词内容使用中文
- 代码、路径、技术术语保留英文
